// Generated by stylus-bindgen
#![allow(clippy::all)]
use stylus_sdk::{alloy_primitives::{Address, U256}, alloy_sol_types::SolType, call::RawCall, prelude::*};

pub struct Contract {
    pub address: Address,
}

impl Contract {
    pub fn new(address: Address) -> Self { Self { address } }

    // Original: approve(address,uint256)
    pub fn approve__0x095ea7b3(&self, to: Address, tokenId: U256) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("095ea7b3").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: balanceOf(address)
    pub fn balance_of__0x70a08231(&self, owner: Address) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("70a08231").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: getApproved(uint256)
    pub fn get_approved__0x081812fc(&self, tokenId: U256) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("081812fc").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: isApprovedForAll(address,address)
    pub fn is_approved_for_all__0xe985e9c5(&self, owner: Address, operator: Address) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("e985e9c5").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: ownerOf(uint256)
    pub fn owner_of__0x6352211e(&self, tokenId: U256) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("6352211e").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: safeTransferFrom(address,address,uint256)
    pub fn safe_transfer_from__0x42842e0e(&self, from: Address, to: Address, tokenId: U256) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("42842e0e").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: safeTransferFrom(address,address,uint256,bytes)
    pub fn safe_transfer_from__0xb88d4fde(&self, from: Address, to: Address, tokenId: U256, data: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("b88d4fde").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: setApprovalForAll(address,bool)
    pub fn set_approval_for_all__0xa22cb465(&self, operator: Address, approved: bool) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("a22cb465").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: transferFrom(address,address,uint256)
    pub fn transfer_from__0x23b872dd(&self, from: Address, to: Address, tokenId: U256) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("23b872dd").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }
}
