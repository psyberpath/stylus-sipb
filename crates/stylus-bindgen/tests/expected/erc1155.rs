// Generated by stylus-bindgen
#![allow(clippy::all)]
use stylus_sdk::{alloy_primitives::{Address, U256}, alloy_sol_types::SolType, call::RawCall, prelude::*};

pub struct Contract {
    pub address: Address,
}

impl Contract {
    pub fn new(address: Address) -> Self { Self { address } }

    // Original: balanceOf(address,uint256)
    pub fn balance_of__0x00fdd58e(&self, account: Address, id: U256) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("00fdd58e").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: balanceOfBatch(address[],uint256[])
    pub fn balance_of_batch__0x4e1273f4(&self, accounts: Vec<u8>, ids: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("4e1273f4").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: isApprovedForAll(address,address)
    pub fn is_approved_for_all__0xe985e9c5(&self, account: Address, operator: Address) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("e985e9c5").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)
    pub fn safe_batch_transfer_from__0x2eb2c2d6(&self, from: Address, to: Address, ids: Vec<u8>, values: Vec<u8>, data: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("2eb2c2d6").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: safeTransferFrom(address,address,uint256,uint256,bytes)
    pub fn safe_transfer_from__0xf242432a(&self, from: Address, to: Address, id: U256, value: U256, data: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("f242432a").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }

    // Original: setApprovalForAll(address,bool)
    pub fn set_approval_for_all__0xa22cb465(&self, operator: Address, approved: bool) -> Result<Vec<u8>, Vec<u8>> {
        let input = hex::decode("a22cb465").unwrap();
        // note: real encoding requires SolType definitions (Milestone 2)
        let result = unsafe { RawCall::new_static().call(self.address, &input)? };
        Ok(result)
    }
}
